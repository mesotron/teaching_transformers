"""
Generates the final training, validation, and test files used in the paper. 
Requires as input some files generated by format_benchmarks.py.
"""

from paths import remainder_path, math_path
import re
import sys
from collections import defaultdict
from enum import Enum

# 'Position ID' scheme to use for the prefix:
# In the initial representation of the input question that is provided as the
# prefix - which should be identical to the questions in the DeepMind math
# dataset, but with only a little preprocessing on the characters or words to
# compensate for the limitations of the byte pair encoding and the positional
# encoding vectors - how do we label the position of each character?
#
# NONE: No labeling of the position of each character
# BY_CHAR: Position indicators placed before each character represent that
# character's position from beginning of prefix
# BY_WORD: the scheme used in the paper: "a format that explicitly labels the
# position of each character within each word (“201 W 202 h 203 a 204 t 200 _
# 201 i 202 s 200 _ …”), in order to circumvent the drawbacks of the default
# position embeddings and tokenizer.
#
class PrefixPID(Enum):
    NONE = 0
    BY_CHAR = 1
    BY_WORD = 2

# Tagging scheme to use for the main text:
# Our representation of each character that is written or looked at on the grid
# necessarily needs to be accompanied by the x, y coordinate of its position on
# the grid, so that we know where to look or write. However, it could also be
# accompanied by a label that flags up the position of each character within
# each word, as in the prefix (BY_WORD_LIKE_PREFIX), or not (NONE).
class TextTag(Enum):
    NONE = 0
    BY_WORD_LIKE_PREFIX = 1

# Name of the question type we are working with in the DeepMind math dataset.
QUESTION_TYPE = 'numbers__div_remainder'

# Initial x, y coordinates to start writing the division problem at.
START_X = 0
START_Y = 2

###########################################
# Functions for mapping coordinates to strings
###########################################
# These facilitate schemes for preprocessing the characters of the input
# question to compensate for BPE/positional encoding vector issues, and allow
# coordinates to be represented in the text of an action string
###########################################

def to_basic_coord(x, y, grid):
    """
    Return string of 0-padded x and y coordinates separated by a comma. `grid`
    is an argument only so that the function pointer signature matches
    to_basic_coord_tag_words_prefix_encoding - this makes it so all functions
    that might be assigned to to_coord have the same signature

    :param int x: x-coordinate
    :param int y: y-coordinate
    :param defaultdict grid: mapping from coords to the symbols located at them
    """
    return f'{x:02d},{y:02d}'

def to_basic_coord_tag_words(x, y, grid, k):
    """
    Return string of 0-padded x and y coordinates separated by a comma, followed
    by a numeric tag k+n where k is some constant, and n is defined such that
    the symbol S at grid[(x,y)] is the nth consecutive symbol in the
    alphanumeric string that S appears in. (n is 0-based).

    :param int x: x-coordinate
    :param int y: y-coordinate
    :param defaultdict grid: mapping from coords to the symbols located at them
    :param int k: any constant
    """
    count = 0
    i = x
    while True:
        i -= 1
        if i >= 0 and re.fullmatch(r'[A-Za-z0-9]', grid[(i, y)]):
            count += 1
        else:
            break
    return f'{x:02d},{y:02d}:{k+count}'

def to_basic_coord_tag_words_prefix_encoding(x, y, grid):
    """
    Return string of 0-padded x and y coordinates separated by a comma, followed
    by a numeric tag 201+n where n is defined such that the symbol S at
    grid[(x,y)] is the nth consecutive symbol in the alphanumeric string that S
    appears in. (n is 0-based). This allows the numeric tags to be represented
    by single bytepair encoding tokens which differ from the tokens used to
    express x and y.

    :param int x: x-coordinate
    :param int y: y-coordinate
    :param defaultdict grid: mapping from coords to the symbols located at them
    """
    return to_basic_coord_tag_words(x, y, grid, 201)

###########################################

def look_at(grid, x, y, run):
    """
    Return the part of a 'look' action string corresponding to 'looking at' a
    grid coordinate (x, y). Specifically: a string consisting of a space,
    followed by a representation of the coordinate, followed by the symbol
    currently located there.

    :param int x: x-coordinate
    :param int y: y-coordinate
    :param defaultdict grid: mapping from coords to the symbols located at them
    :param RunParams run: configuration of this training/validation/test run
    """
    return f' {run.to_coord(x, y, grid)} {grid[(x, y)]}'

def register(text, grid, x, y, char, run):
    """
    Write a particular character to a grid location.

    Return a 2-tuple such that the first element is a space, followed by a
    representation of the coordinate, followed by new symbol located there; the
    second element is the grid itself. This is not strictly necessary to return,
    but reminds us that this function modifies the grid.

    :param str text: action string that we want to append the write action onto
    :param defaultdict grid: mapping from coords to the symbols located at them
    :param int x: x-coordinate
    :param int y: y-coordinate
    :param str char: character to write
    :param RunParams run: configuration of this training/validation/test run
    """
    text += f' {run.to_coord(x, y, grid)} {char}'
    grid[(x, y)] = char
    return (text, grid)

def get_lookstr_index(lookstr, index):
    """
    Given a lookstring (a string corresponding to a full 'look' action) that
    represents the action of looking at a number of 1 or more digits, and an
    index, return the indexth digit of that number, preceded by its position
    tag.

    :param str lookstr: the lookstring (a string corresponding to a full 'look'
                        action)
    :param int index:  the index of the desired digit
    """
    lookstr = re.sub(r'(\d+),(\d+):(\d+) _ ', '', lookstr)
    tokens = lookstr.strip().split(' ')
    return tokens[index * 2] + ' ' + tokens[index * 2 + 1]

def get_comparison_narration(look1, look2, value1, value2, compare_digits):
    """
    Return the string representing the sequence of actions that corresponds to
    comparing two numbers.

   :param str look1: the lookstring (string corresponding to a full 'look'
                     action) for the first number
    :param str look2: the lookstring for the second number
    :param int value1: the value of the first number
    :param int value2: the value of the second number
    :param bool compare_digits: whether to start out by comparing how many
                                digits the two numbers have

    """
    str_value1 = str(value1)
    str_value2 = str(value2)
    digit_count1 = len(str_value1)
    digit_count2 = len(str_value2)
    output = ''
    if compare_digits:
        output = f' {{ compare }} look{look1} {{ {digit_count1} digits }} look{look2} {{ {digit_count2} digits'

    if digit_count1 == digit_count2:
        if compare_digits:
            output += f' equal }}'
        for i in range(digit_count1):
            digit_i1 = get_lookstr_index(look1, i)
            digit_i2 = get_lookstr_index(look2, i)
            digit1 = int(str_value1[i])
            digit2 = int(str_value2[i])
            output += f' look {digit_i1} look {digit_i2} {{ {digit1} , {digit2}'
            if digit1 > digit2:
                output += f' smaller }}'
                break
            elif digit1 < digit2:
                output += f' larger }}'
                break
            else:
                output += f' equal }}'

    elif digit_count1 > digit_count2:
        output += f' smaller }}'
    elif digit_count1 < digit_count2:
        output += f' larger }}'
    return output

class RunParams:
    """
    Structure for storing the configuration of a given training, validation, or
    test file

    function to_coord: Function for mapping coordinates to strings (see section
                       entitled 'Functions for mapping coordinates to strings'
                       earlier in file)
    int max_train_examples: Maximum number of training examples to use
    int max_validation_examples: Maximum number of validation examples to
                                 generate
    int max_test_examples: Maximum number of test examples to generate
    bool coordinates: Whether to include the coordinates that indicate where
                      each character appears on the grid
    PrefixPID prefix_pid_style: Scheme for preprocessing the characters of the
                                input question to compensate for BPE/positional
                                encoding vector issues
    TextTag text_tag_style: Scheme for representing the positions/coordinates
                            of various symbols written on the grid
    bool look: whether to include 'look' actions
    bool narrate: whether to include no-ops
    bool narrate_positions: whether to include clues about the grid locations
                            we want it to pay attention to in no-ops
    int endcap_length: the strings of characters that signal where one problem
                       ends and another begins - how long to make them?

    int code: a little code that compactly summarizes the RunParams, useful for
    naming run files. Does not need to be provided, is constructed by the class
    itself
    """

    def __init__(self,
                 to_coord=None,
                 max_train_examples=sys.maxsize,
                 max_validation_examples=100,
                 max_test_examples=100,
                 coordinates=True,
                 prefix_pid_style=PrefixPID.BY_WORD,
                 text_tag_style=TextTag.NONE,
                 look=True,
                 narrate=True,
                 narrate_positions=False,
                 endcap_length=50
                 ):

        self.to_coord = to_coord
        if self.to_coord is None:
            if text_tag_style == TextTag.NONE:
                self.to_coord = to_basic_coord
            elif text_tag_style == TextTag.BY_WORD_LIKE_PREFIX:
                self.to_coord = to_basic_coord_tag_words_prefix_encoding
            else:
                raise Exception('Unrecognized text_tag_style')
        else:
            if text_tag_style != TextTag.NONE:
                raise Exception('to_coord is specified, but so is text_tag_style, which constrains the value of to_coord')

        self.max_train_examples = max_train_examples
        self.code = '_' + str(max_train_examples)
        self.max_validation_examples = max_validation_examples
        self.max_test_examples = max_test_examples
        self.coordinates = coordinates
        self.code += ('G' if coordinates else '')

        self.prefix_pid_style = prefix_pid_style
        self.code += 'p' + str(prefix_pid_style.value)
        self.text_tag_style = text_tag_style
        self.code += 't' + str(text_tag_style.value)

        self.look = look
        self.code += ('L' if look else '')
        self.narrate = narrate
        self.code += ('N' if narrate else '')
        self.narrate_positions = narrate_positions
        self.code += ('+' if narrate_positions else '')
        self.endcap_length = endcap_length
        self.code += ('e' + str(endcap_length)) if endcap_length != 50 else ''


def clean_coordinates(s):
    """ Return a version of `s` with the coordinates erased. """
    return re.sub(r' \d\d,\d\d', '', ' ' + s)

def clean_position_ids(s):
    """ Return a version of `s` with the position ids erased. """
    return re.sub(r' \d\d\d', '', ' ' + s).strip()

def clean(text, drop_annotations=True):
    """
    Return a version of `text` with underscores and spaces between characters
    removed, and optionally position ids, coordinates and tags as well.

    :param str text:  text to clean
    :param bool drop_annotations:  Whether to erase position ids, coordinates
                                 and tags
    """
    if drop_annotations:
      text = re.sub(r' \d\d,\d\d(:\d\d\d)?', '', ' ' + text)
      text = re.sub(r' \d\d\d', '', ' ' + text)
    text = text.replace(' ', '')
    text = text.strip('_')
    return text

def write_division_problem(prefix, run, grid):
    """
    Given the initial prefix representing the division problem to be solved,
    return a 3-tuple consisting of:
    - the action string consisting of the series of actions that writes the
    division problem to the grid
    - the divisor (int)
    - the dividend (int)

    :param str prefix: initial prefix representing the division problem to be
                       solved
    :param RunParams run: configuration of this training/validation/test run
    :param defaultdict grid: mapping from coords to the symbols located at them

    """
    text = ' write'
    pattern = r'w/h/e/n/_ (.*?)/_/i/s/_/d/i/v/i/d/e/d/_/b/y/_ (.*?)/(\.|\?)'.replace(r'/', r' \d\d\d ')

    m = re.search(pattern, prefix)
    dividend_str = clean_position_ids(m.group(1))
    divisor_str = clean_position_ids(m.group(2))
    dividend_tokens = dividend_str.split()
    divisor_tokens = divisor_str.split()

    x = START_X
    y = START_Y
    to_coord = run.to_coord
    for token in divisor_tokens:
        text, grid = register(text, grid, x, y, token, run)
        x += 1
    text, grid = register(text, grid, x, y, 'ſ', run)
    x += 1
    for token in dividend_tokens:
        text, grid = register(text, grid, x, y, token, run)
        x += 1
    return (text, int(''.join(divisor_tokens)), int(''.join(dividend_tokens)))


def spacify(x):
    """
    Given a number or string, return a string that contains all of the
    digits/characters of the original, but separated by spaces. The result
    neither begins nor ends with a space.
    """
    s = str(x)
    out_string = ''
    for char in s:
        out_string += char + ' '
    return out_string.strip()


def look_from_coord_n_spaces(x, y, n, run, grid):
    """
    Return a portion of an action string that represents where we are currently
    'looking'. Start at (x, y), and continue going towards the right, reading a
    total of n characters.

    :param int n: number of characters to read
    :param RunParams run: configuration of this training/validation/test run
    :param defaultdict grid: mapping from coords to the symbols located at them
    """
    look_str = ''

    for i in range(n):
        look_str += look_at(grid, x, y, run)
        x += 1
    return look_str


def look_from_coord_to_symbol(x, y, symbol, run, grid):
    """
    Return a portion of an action string that represents where we are currently
    'looking'. Start at (x, y), and continue going towards the right until you
    see `symbol`. If you never see `symbol`, then stop as soon as: you see
    nothing at all (underscore) AND you have looked at more than one tile.

    :param int x: x-coordinate of start location
    :param int y: y-coordinate of start location
    :param str symbol: symbol to stop at
    :param RunParams run: configuration of this training/validation/test run
    :param defaultdict grid: mapping from coords to the symbols located at them
    """
    look_str = ''
    look_str += look_at(grid, x, y, run)
    count = 1
    while True:
        if grid[(x, y)] == symbol and count > 1:
            break
        if grid[(x, y)] == '_' and count > 1:
            break
        count += 1
        x += 1
        look_str += look_at(grid, x, y, run)
    return x, look_str

def look_at_divisor(divisor, grid, run):
    """
    Return a 3-tuple consisting of:
    - x-coordinate just after end of the divisor
    - y-coordinate just after end of the divisor
    - portion of an action string that represents looking at each digit in the divisor

    :param int divisor: the divisor
    :param RunParams run: configuration of this training/validation/test run
    :param defaultdict grid: mapping from coords to the symbols located at them
    """
    x = 0
    y = 2
    look_str = ''
    for c in str(divisor):
        look_str += look_at(grid, x, y, run)
        x += 1
    return (x, y, look_str)

def trim_blanks(lookstr, run):
    """
    Return version of `lookstr` having trimmed underscores from beginning and
    end (e.g., having trimmed underscores from the output of look_from_coord_to_symbol).

    :param str lookstr: a string corresponding to a 'look' action
    :param RunParams run: configuration of this training/validation/test run
    """
    if (run.text_tag_style == TextTag.NONE):
        lookstr = re.sub(r'^( _)*', '', lookstr)
        lookstr = re.sub(r'( _)*$', '', lookstr)
    else:
        lookstr = re.sub(r'^( \d\d,\d\d(:\d\d\d)? _)*', '', lookstr)
        lookstr = re.sub(r'( \d\d,\d\d(:\d\d\d)? _)*$', '', lookstr)
    return lookstr

def write_interim_remainder(text, gm_str, divisor, dividend, number_str, run, grid, number_x, number_y, quotient_x):
    """
    Add to `text` the action substring for the part of a division problem that
    computes an 'interim remainder' - which may be the final remainder if there
    are no further numbers to 'pull down' from the dividend.
    If there is a further digit to pull down, return (text, number, number_x,
    number_y, quotient_x), where 'text' is the text of the action substring,
    number is the the new number that the divisor needs to go into (created by
    doing the subtraction problem and pulling down the next digit), number_x &
    number_y are its x and y coordinates, and quotient_x is the x-coordinate of
    the digit of the quotient we most recently updated.
    If there is no further digit to pull down, meaning that the remainder
    computed is the final one, then return (text, None, None, None, None,
    str_remainder).

    :param str text: action string so far
    :param str gm_str: greatest multiple of the divisor that is less than int(number_str)
    :param int divisor: main divisor
    :param int dividend: main dividend
    :param str number_str: the current number to divide into
    :param RunParams run: configuration of this training/validation/test run
    :param defaultdict grid: mapping from coords to the symbols located at them
    :param int number_x: x-coordinate of number_str
    :param int number_y: y-coordinate of number_str
    :param int quotient_x: x-coordinate of the most recently updated digit of the quotient
    """

    # Write the minus sign and the greatest common multiple in the locations
    # they need to be to set up the subtraction problem

    x = number_x - 1
    y = number_y + 1
    text += ' write'
    text, grid = register(text, grid, x, y, '-', run)

    x = number_x + (len(number_str) - len(gm_str))
    original_last_digit_x = x + len(gm_str)
    y = number_y + 1
    text += ' write'
    for i in range(x, x + len(gm_str)):
        text, grid = register(text, grid, i, y, gm_str[i - x], run)

    # All set up - we can start to subtract.
    x = x + len(gm_str) - 1
    y = number_y

    while True:
        value1 = grid[(x, y)]
        look1 = look_at(grid, x, y, run)
        y += 1
        value2 = grid[(x, y)]
        look2 = look_at(grid, x, y, run)

        answer_x = x        # keeping track for easy reference in the future
        answer_y = y + 1

        if (value1 == '_' or value2 == '-'):
            break

        value1 = int(value1) if value1.isdigit() else 0
        value2 = int(value2) if value2.isdigit() else 0
        text += get_comparison_narration(look1, look2, value1, value2, False)
        if value1 < value2:
            text += ' { borrow a 1 }'
            y -= 1
            while True:
                x -= 1
                look_to_borrow = look_at(grid, x, y, run)
                # We should never run off the edge of the left side of the
                # subtraction problem when borrowing a 1:
                assert(grid[(x, y)] != '_')
                if run.look:
                    text += ' look' + look_to_borrow
                if grid[(x, y)] == '0':
                    text += ' { change 0 to 9 }'
                    text += ' write'
                    text, grid = register(text, grid, x, y, '9', run)
                elif grid[(x, y)] in '123456789':
                    text += f' {{ {grid[(x, y)]} - 1 = {int(grid[(x, y)]) - 1} }}'
                    text += ' write'
                    text, grid = register(text, grid, x, y, str(int(grid[(x, y)]) - 1), run)
                    break

            text += f' {{ {spacify(value1 + 10)} - {value2} = {value1 + 10 - value2} }}'
            text += ' write'
            text, grid = register(text, grid, answer_x, answer_y, str(value1 + 10 - value2), run)
        else:
            text += f' {{ {value1} - {value2} = {value1 - value2} }}'
            text += ' write'
            text, grid = register(text, grid, answer_x, answer_y, str(value1 - value2), run)

        x = answer_x - 1
        y = answer_y - 2

    # At this point we should have our answer. Time to either
    # - report our result (remainder) as the answer, if there is not a next digit to pull down; or
    # - pull down the next digit, and return the new 'number' that the divisor needs to go into,
    #   if there is a next digit to pull down.
    # First, if there are any leading zeros in the answer, erase them.
    # This should hopefully also help GPT establish where the interim remainder begins.

    y = y + 1
    interim_remainder_x = x
    interim_remainder_y = y

    x_offset = 0
    for x_i in range(x + 1, original_last_digit_x + 1):
        look_next_digit = look_at(grid, x_i, y, run)
        if run.look:
            text += ' look' + look_next_digit

        if grid[(x_i, y)] in '123456789':
            interim_remainder_x = x_i
            break
        elif grid[(x_i, y)] == '0':
            text += ' write'
            text, grid = register(text, grid, x_i, y, '_', run)
        elif grid[(x_i, y)] == '_':
            # We might see this condition if the answer
            # is ALL zeros (because there was no remainder), and we run
            # through all of them to emerge on the other side
            interim_remainder_x = x_i - 1
            x_offset += 1

    text += ' { read the answer }'

    x, look_answer = look_from_coord_to_symbol(interim_remainder_x, y, '_', run, grid)

    if run.look:
        text += ' look' + look_answer

    # This next bit is a loop just in case we need to pull down multiple digits -
    # we'll break out of it as soon as the new number exceeds the divisor
    while True:

        # Is there a next digit to pull down?
        look_next_digit = look_at(grid, x, START_Y, run)
        if run.look:
            text += ' look' + look_next_digit

        if (grid[(x, START_Y)] == '_'):
            # If not, we have our answer, report it!
            remainder_str = clean(look_answer)
            if remainder_str == '':
                remainder_str = '0'
            text += f' {{ final remainder is {spacify(remainder_str)} }}'
            return (text, None, None, None, None, remainder_str)
        else:
            # If so:
            # - pull down the next digit
            # - figure out the next 'number'
            # - Is the result larger than the divisor?
            #    If so, return the number (and the x, y coordinates of its first digit)
            #    If not, try to pull down another number, repeating this whole little
            #    loop at the end

            text += ' write'
            text, grid = register(text, grid, x, y, grid[(x, START_Y)], run)
            _, look_answer = look_from_coord_to_symbol(interim_remainder_x + x_offset, interim_remainder_y, '_', run, grid)

            number_str = clean(look_answer)
            number = 0 if number_str == '' else int(number_str)

            return (text, number_str, interim_remainder_x + x_offset, interim_remainder_y, quotient_x, None)

def write_greatest_multiple(text, divisor, dividend, number_str, run, grid,
                            quotient_x, number_x, number_y, first_call):
    """
    Return a 2-tuple containing the
    - action substring that corresponds to finding the greatest multiple of the
      divisor that is less than int(number_str)
    - this greatest multiple (as a string)
    Involves a lot of addition in the scratch area.

    :param str text: action string so far
    :param int divisor: main divisor
    :param int dividend: main dividend
    :param str number_str: the number to divide into (as string)
    :param RunParams run: configuration of this training/validation/test run
    :param defaultdict grid: mapping from coords to the symbols located at them
    :param int quotient_x: x-coordinate of the most recently updated digit of
                           the quotient
    :param int number_x: x-coordinate of number_str
    :param int number_y: y-coordinate of number_str
    :param bool first_call: is this the first time this function is being called
                            during this division problem?
    """

    number = int(number_str)

    # Start by putting down a tentative quotient of 0
    quotient_y = 1
    quotient = 0
    text += ' write'
    text, grid = register(text, grid, quotient_x, quotient_y, str(quotient), run)

    # ************************************************
    # Do repeated addition, increasing the quotient so long as we are less than 'number'
    # ************************************************

    # - Add the divisor to itself. Start by just writing the initial addition problem
    text += ' clear'

    if run.look:
        x, y, look_str = look_at_divisor(divisor, grid, run)
        text += ' look' + look_str
        text += ' write'

    x = 70
    y = 0

    for c in ('_' * (len(str(divisor)) - 1)) + '0':
        x += 1
        text, grid = register(text, grid, x, y, c, run)

    x = 70
    y = 1

    while True:
        text, grid = register(text, grid, x, y, '+', run)
        carry_the_1 = False

        # Position divisor properly
        x = 70

        for c in str(divisor):
            x += 1
            text, grid = register(text, grid, x, y, c, run)

        # - Next, solve the addition problem
        for i in range(len(str(divisor)) + 1):
            y -= 1
            value1 = grid[(x, y)]
            look1 = look_at(grid, x, y, run)
            y += 1
            look2 = look_at(grid, x, y, run)
            value2 = grid[(x, y)]
            if run.look:
                text += ' look' + look1 + look2

            if (value2 == '+'):
                break

            value1 = int(value1) if value1.isdigit() else 0
            value2 = int(value2) if value2.isdigit() else 0
            value_sum = value1 + value2

            text += f' {{{look1 if run.narrate_positions else value1}' + \
                        f' +{look2 if run.narrate_positions else value2} = {spacify(value1 + value2)} }}'
            if carry_the_1:
                text += f' {{ {spacify(value1 + value2)} + 1 = {spacify(value1 + value2 + 1)} }}'
                value_sum += 1

            y += 1
            text += ' write'
            text, grid = register(text, grid, x, y, str(value_sum % 10), run)

            if (value_sum >= 10):
                carry_the_1 = True
                text += ' { carry the 1 }'
            else:
                carry_the_1 = False
            x -= 1
            y -= 1

        # We have now observed that we are at the edge of the addition problem
        # -- having observed a _ and a + -- and it is time to wrap up
        if carry_the_1:
            text += ' { 0 + 0 = 0 } { 0 + 1 = 1 }'
            y += 1
            text += ' write'
            text, grid = register(text, grid, x, y, '1', run)
        else:
            text += ' { 0 + 0 = 0 }'
            y += 1

        # ************************************************
        # Compare: is the result greater than 'number'?
        # ************************************************

        # Look at the result
        _, look_result = look_from_coord_to_symbol(x, y, '_', run, grid)
        result = int(clean(look_result))

        # Look at the number we're comparing against
        if first_call:
            look_number = look_from_coord_n_spaces(number_x, number_y, len(str(number)), run, grid)
        else:
            # the other branch doesn't work when there's a 0 in front
            # (but there never will be when first_call is true)
            _, look_number = look_from_coord_to_symbol(number_x, number_y, '_', run, grid)

        number = int(clean(look_number))

        text += get_comparison_narration(look_result, look_number, result, number, True)

        # If result > number, stop and return the greatest multiple that is less than 'number'
        if (result > number):
            y -= 2
            _, look_greatest_multiple = look_from_coord_to_symbol(x, y, '_', run, grid)
            if run.look:
                text += ' look' + look_greatest_multiple
            gm_str = clean(look_greatest_multiple)
            return text, gm_str
        else:
            # Otherwise, increment the quotient
            look_quotient = look_at(grid, quotient_x, quotient_y, run)
            if run.look:
                text += ' look' + look_quotient
            text += f' {{{look_quotient if run.narrate_positions else quotient} + 1 = { quotient + 1 } }}'
            quotient += 1
            text += ' write'
            text, grid = register(text, grid, quotient_x, quotient_y, str(quotient), run)

            # Position the cursor to be ready to write a plus sign, and let the
            # loop take its course
            # (prepare to keep adding the divisor until result > number)
            if carry_the_1:
                # if the sum was one digit longer than the inputs, then move
                # the plus sign for the next problem a space to the left
                x -= 1
            y += 1


def write_first_subproblem(text, divisor, dividend, run, grid):
    """
    Execute the steps at the very beginning of solving a division problem,
    specifically those above and including the first diamond in Camos & Baumer
    (2015) Fig 3: if N starts as the number of digits in the divisor, see if the
    N leftmost digits in the dividend are larger than the divisor; if not, keep
    add 1 to N and repeat. Return a 2-tuple consisting of

    - the action string given in `text` + the actions to accomplish the above
    - the N leftmost digits in the dividend, for first N that yields a number
      larger than the divisor (as int)

    :param str text: action string so far
    :param int divisor: main divisor
    :param int dividend: main dividend
    :param RunParams run: configuration of this training/validation/test run
    :param defaultdict grid: mapping from coords to the symbols located at them
    """

    n = len(str(divisor)) # 'N = number of digits in divisor'

    divisor_end, look_divisor = look_from_coord_to_symbol(0, START_Y, 'ſ', run, grid)  # look at divisor

    number = int(str(dividend)[:n]) # 'Number = N leftmost digits in dividend'

    dividend_start = divisor_end + 1
    look_number = look_from_coord_n_spaces(dividend_start, START_Y, n, run, grid) # look at N leftmost digits in dividend

    text += get_comparison_narration(look_divisor, look_number, divisor, number, True)
    while (number < divisor):
        n += 1
        number = int(str(dividend)[:n])
        look_number = look_from_coord_n_spaces(dividend_start, START_Y, n, run, grid) # look at N leftmost digits in dividend
        if run.look:
            text += ' look' + look_number

        text += get_comparison_narration(look_divisor, look_number, divisor, number, True)
    return (text, number)


def label_positions_by_word(cue, prefix_pid_style):
    """
    Return a list consisting of the cue split out character by character,
    interspersed with position indicators; position indicators represent
    position from beginning of word. This is the scheme referenced in the paper:
    "a format that explicitly labels the position of each character within each
    word (“201 W 202 h 203 a 204 t 200 _ 201 i 202 s 200 _ …”), in order to
    circumvent the drawbacks of the default position embeddings and tokenizer.

   :params str cue: string to split out character by character and to
                    intersperse with position indicators
    :params PrefixPID prefix_pid_style: 'Position ID' scheme to use for the
                                        prefix (see PrefixPID class)
    """
    words = cue.split()
    prefix_tokens = []
    for word in words:
        if prefix_pid_style == PrefixPID.BY_WORD:
            prefix_tokens.extend([str(i + 200) + ' ' + x for i, x in enumerate(word, 1)])
            prefix_tokens.extend(['200', '_'])

    return prefix_tokens


def elaborate(cue, target, run, exclude_answer):
    """
    Given a cue (math problem to be answered) and a target, elaborate the cue by
    preprocessing the it to address the limitations of the positional encoding
    vectors, and constructing an action string to help GPT-Neo learn how to get
    from the cue to the answer. Return this action string.

    :param str cue: the math problem to be answered
    :param str target: desired answer
    :param RunParams run: configuration of this training/validation/test run
   :param bool exclude_answer: whether to output the preprocessed prefix +
                               action string or just the prefix (i.e. for
                               generating test files)
    """

    # Write out the cue character by character, interspersed with position indicators
    if run.prefix_pid_style == PrefixPID.BY_CHAR:
        # Position indicators represent position from beginning of prefix
        prefix_tokens = [str(i).zfill(2) + ' ' + x for i, x in enumerate(cue.replace(' ', '_'))]
    elif run.prefix_pid_style == PrefixPID.BY_WORD:
        # Position indicators represent position from beginning of word
        prefix_tokens = label_positions_by_word(cue, run.prefix_pid_style)

    prefix = ('\u00ec' * run.endcap_length) + ' ' + (' '.join(prefix_tokens))
    prefix += ' |'

    # Write out the division problem
    grid = defaultdict(lambda:'_')  # mapping from coords to the symbols located at them
    text, divisor, dividend = write_division_problem(prefix, run, grid)

    ### First subproblem ###

    # Execute the steps above and including the first diamond in Camos & Baumer Fig 3
    text, number = write_first_subproblem(text, divisor, dividend, run, grid)
    number_str = str(number)

    # First addition
    quotient_x = len(str(divisor)) + len(number_str)
    number_x = len(str(divisor)) + 1
    number_y = START_Y
    text, gm_str = write_greatest_multiple(text, divisor, dividend, number_str, run, grid,
                                        quotient_x, number_x, number_y, first_call=True)

    # First subtraction
    text, number_str, number_x, number_y, quotient_x, remainder = \
        write_interim_remainder(text, gm_str, divisor, dividend, number_str, run, grid, number_x, number_y, quotient_x)

    # Continue on until we solve the problem
    while number_str is not None:
        quotient_x += 1
        text, gm_str = write_greatest_multiple(text, divisor, dividend, number_str, run, grid,
                                            quotient_x, number_x, number_y, first_call=False)
        text, number_str, number_x, number_y, quotient_x, remainder = \
            write_interim_remainder(text, gm_str, divisor, dividend, number_str, run, grid, number_x, number_y, quotient_x)


    # Verify that the target equals the remainder
    assert(target == remainder);

    # Finish up
    if not run.prefix_pid_style:
        prefix = clean_position_ids(prefix)
    if not run.coordinates:
        text = clean_coordinates(text)
    if not run.text_tag_style:
        text = clean_position_ids(text)
    if exclude_answer:
        return prefix
    else:
        return prefix + text

def elaborate_file(input_filename, output_filename, run, max_examples, exclude_answer=False):
    """
    Given an input file, elaborate all the cues within it by preprocessing the
    prefix on each line to address the limitations of the positional encoding
    vectors, and constructing an action string to help GPT-Neo learn how to get
    from the prefix to the answer. Write the results to `output_filename`.
    Intended to be called by generate_training_and_validation and generate_test.

    :param str input_filename: file to read
    :param str output_filename: file to write
    :param RunParams run: RunParams with configuration of this run
    :param int max_examples: maximum number of examples (lines) to read from
                             input_filename
    :param bool exclude_answer: whether to output the preprocessed prefix +
                                action string or just the prefix (i.e. for
                                generating test files)
    :return: None
    """

    with open(input_filename, 'r') as in_file:
        with open(output_filename, 'w', encoding='utf-8') as out_file:

            for i, line in enumerate(in_file):
                if i >= max_examples:
                    break

                line = line.strip()
                if line != '':
                    partitioned = line.partition('|')

                    cue = partitioned[0]
                    target = partitioned[2]
                    text = elaborate(cue, target, run, exclude_answer)
                    out_file.write(text + '\n')

def generate_training_and_validation(output_filename_prefix, run):
    """
    Create elaborated training and validation files by reading in the
    unelaborated training file train_{QUESTION_TYPE}.txt, and the unelaborated
    validation file validation_{QUESTION_TYPE}.txt, and writing out elaborated
    versions. In the title of the output files, include a little code
    corresponding to the particular configuration settings represented by the
    RunParams object `run`.

    :param str output_filename_prefix: prefix to prepend to names of output files
    :param RunParams run: configuration of this training/validation/test run
    :return: None
    """

    print(f'Generating training data for {output_filename_prefix + run.code}...')

    elaborate_file(input_filename=math_path + 'train_' + QUESTION_TYPE + '.txt',
             output_filename=remainder_path + output_filename_prefix + run.code + '_training.txt',
             run=run, max_examples=run.max_train_examples)


    print(f'Generating validation data for {output_filename_prefix + run.code}...')

    elaborate_file(input_filename=math_path + 'validation_' + QUESTION_TYPE + '.txt',
             output_filename=remainder_path + output_filename_prefix + run.code + '_validation.txt',
             run=run, max_examples=run.max_validation_examples, exclude_answer=False)


def generate_test(output_filename_prefix, distribution_prefix, run, test_id_list=None):
    """
    Create elaborated test files by reading in unelaborated test files, and
    writing out elaborated versions. In the title of the output files, include a
    little code corresponding to the particular configuration settings
    represented by the RunParams object `run`.

    :param str output_filename_prefix: prefix to prepend to names of output files
    :param str distribution_prefix: 'samedist' or 'interpolated'
    :param RunParams run: configuration of this training/validation/test run
    :param it test_id_list: an iterable of test ids to read in. Default is range(5)
    :return: None
    """
    print(f'Generating test data for {output_filename_prefix + run.code} ({distribution_prefix})...')

    if test_id_list is None:
        test_id_list = range(5)

    for i in test_id_list:
        elaborate_file(input_filename=f'{math_path}{distribution_prefix}test_{QUESTION_TYPE}_set{i}.txt',
                 output_filename=f'{remainder_path}{output_filename_prefix}{run.code}_{distribution_prefix}testset{i}.txt',
                 run=run, max_examples=run.max_test_examples, exclude_answer=False)

# Generate the final training, validation, and test files

generate_training_and_validation('remainder', RunParams(max_train_examples=200,
                                                    prefix_pid_style=PrefixPID.BY_WORD,
                                                    text_tag_style=TextTag.BY_WORD_LIKE_PREFIX,
                                                    coordinates=True,
                                                    narrate_positions=True,
                                                    look=True));

generate_test('remainder', 'samedist', RunParams(
                                    max_train_examples=200,
                                    max_test_examples=500,
                                    prefix_pid_style=PrefixPID.BY_WORD,
                                    text_tag_style=TextTag.BY_WORD_LIKE_PREFIX,
                                    coordinates=True,
                                    narrate_positions=True,
                                    look=True),
                                    [500])

generate_test('remainder', 'interpolated', RunParams(
                                    max_train_examples=200,
                                    max_test_examples=500,
                                    prefix_pid_style=PrefixPID.BY_WORD,
                                    text_tag_style=TextTag.BY_WORD_LIKE_PREFIX,
                                    coordinates=True,
                                    narrate_positions=True,
                                    look=True),
                                    [500])
